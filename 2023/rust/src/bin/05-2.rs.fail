use std::cmp::min;
use std::fs::File;
use std::io::{ self, BufRead, BufReader, Lines };

fn main() {
    let filename = "data/05.txt";

    let mut lines = read_lines(filename).unwrap();

    let seed_line = lines.next().unwrap().unwrap();
    let mut seed_pairs = parse_seed_pairs(&seed_line);

    let current_map: &mut Vec<Vec<usize>> = &mut Vec::new();
    
    for line in lines {
        if let Ok(txt) = line {
            if txt.contains("map") {
                seed_pairs = update_seed_pairs(seed_pairs, current_map);
                *current_map = vec![];
            } else if txt.contains(char::is_numeric) {
                update_map(current_map, &txt);
            }
        }
    }
    let mut lowest_seed: usize = usize::MAX;
    seed_pairs = update_seed_pairs(seed_pairs, current_map);
    for (s, _) in seed_pairs.iter() {
        lowest_seed = min(*s, lowest_seed);
    }
    println!("Lowest: {}", lowest_seed);
}

fn parse_seed_pairs(seed_line: &str) -> Vec<(usize, usize)> {
    let space_separated = seed_line.get(7..).unwrap();
    let seed_vec = space_separated.split(" ").collect::<Vec<&str>>().iter().map(|s| {s.parse::<usize>().unwrap()}).collect::<Vec<usize>>();

    let n = seed_vec.len()/2;

    let mut seed_pairs: Vec<(usize, usize)> = vec![];
    for i in 0..n {
        let t = (seed_vec[2*i], seed_vec[2*i+1]);
        seed_pairs.push(t);
    }
    seed_pairs
}

fn update_map(map: &mut Vec<Vec<usize>>, line: &str) {
    let nums = line.split(" ").collect::<Vec<&str>>().iter().map(|s| {s.parse::<usize>().unwrap()}).collect::<Vec<usize>>();
    map.push(nums)
}

fn read_lines(filename: &str) -> io::Result<Lines<BufReader<File>>> {
    let file = File::open(filename)?;
    Ok(BufReader::new(file).lines())
}

fn update_seed_pair<'a>(seed_pair: (usize, usize), map: &mut Vec<Vec<usize>>) -> Vec<(usize, usize)> {
    if map.len() == 0 {
        return vec![seed_pair];
    }
    let (s, r) = seed_pair;
    for interval in map.iter() {
        let (dest_start, src_start, range_len) = (interval[0], interval[1], interval[2]);
        if s < src_start && src_start <= s + r && s + r <= src_start + range_len {
            return vec![(s, src_start - s), (dest_start, s + r - src_start)];
        } else if src_start <= s && s + r <= src_start + range_len {
            return vec![(dest_start + s - src_start, r)];
        } else if src_start <= s && s <= src_start + range_len && src_start + range_len <= s + r {
            return vec![(dest_start + s - src_start, range_len + src_start - s), (src_start + range_len, s + r - src_start - range_len)];
        }
    }
    return vec![(s, r)];
}

fn update_seed_pairs<'a>(seed_pairs: Vec<(usize, usize)>, map: &mut Vec<Vec<usize>>) -> Vec<(usize, usize)> {
    let mut new_seed_pair: Vec<(usize, usize)> = vec![];
    for sp in seed_pairs.iter() {
        let mapped_sp = update_seed_pair(*sp, map);
        for p in mapped_sp.iter() {
            new_seed_pair.push(*p);
        }
    }
    new_seed_pair
}
